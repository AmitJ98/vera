# Copyright 2026 Google LLC
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

from typing import Annotated, Self, override

from pydantic import Field, PlainSerializer

from vera import CsvColumn, CsvRow, ScoreRange, TestCase, TestCaseInput, TestCaseOutput

from . import utils


class SqlQueryInput(TestCaseInput):
    """
    Represents the input for a SQL generation test case.
    The 'user_query' is the natural language question.
    """

    user_query: str

    @override
    def to_description_prompt(self) -> str:
        """Formats the input for the LLM prompt.

        Returns:
            A prompt that represents the user's input

        """
        return f"User Query:\n\n<user_request>{self.user_query}</user_request>\n"


class SqlQueryOutput(TestCaseOutput):
    """
    Represents the output of the SQL generation feature.
    Contains the raw generated SQL string.
    """

    sql_query: str

    @override
    def to_output_description_prompt(self) -> str:
        """Formats the output for the LLM Judge prompt.

        Returns:
            A prompt the feature's output
        """
        return f"Generated SQL:\n\n<generated_results>{self.sql_query}\n</generated_results>\n"


class SqlTestCase(TestCase):
    """
    A full test case for SQL generation, linking SqlQueryInput to the engine.
    """

    input: SqlQueryInput


class StaticChecksColumn(CsvColumn):
    """
    Columns in the report generated by programmatic (static) checks.
    """

    static_checks_score_pass: bool
    static_checks_reasoning: str


class LlmChecksColumn(CsvColumn):
    """
    Columns in the report generated by the LLM Judge.
    These fields must match the schema expected by the Judge based on the Rubric.
    """

    syntax_and_executive_validity_score_pass: Annotated[
        bool,
        Field(
            description=(
                "Syntax and executive validity score, pass or fail, based on the scoring rubric"
            )
        ),
    ]
    syntax_and_executive_validity_score_reasoning: Annotated[
        str, Field(description="The reason for the Syntax and Executive Validity Score score")
    ]
    business_logic_score: Annotated[
        int,
        Field(
            description="The score for the business logic according to the scoring rubric (1-5)",
            examples=[1, 2, 3, 4, 5],
        ),
    ]
    business_logic_score_reasoning: Annotated[
        str, Field(description="The reason for the Business Logic score")
    ]
    safety_compliance_score_pass: Annotated[
        bool,
        Field(description="The safety compliance score, pass or fail, based on the scoring rubric"),
    ]
    safety_compliance_score_reasoning: Annotated[
        str, Field(description="The reason for the safety compliance score")
    ]
    efficiency_score: Annotated[
        int,
        Field(
            description="The score for the efficiency according to the scoring rubric (1-5)",
            examples=[1, 2, 3, 4, 5],
        ),
    ]
    efficiency_score_reasoning: Annotated[
        str, Field(description="The reason for the Efficiency score")
    ]


class SqlQueryRow(CsvRow[SqlQueryInput, SqlQueryOutput, LlmChecksColumn, StaticChecksColumn]):
    """
    The final data model representing a single row in the CSV report.
    It aggregates data from the test case, feature output, and both evaluation layers.
    """

    name: Annotated[str, Field(alias="Test Case Name")]
    description: Annotated[str, Field(alias="Test Case Description")]
    input: Annotated[SqlQueryInput, PlainSerializer(lambda x: x.user_query), Field(alias="Input")]
    output: Annotated[SqlQueryOutput, PlainSerializer(lambda x: x.sql_query), Field(alias="Output")]
    syntax_and_executive_validity_score_pass: Annotated[
        bool, Field(alias="Syntax and Executive Validity Score (Pass/Fail)")
    ]
    syntax_and_executive_validity_score_reasoning: Annotated[
        str, Field(alias="Syntax and Executive Validity Score Reasoning")
    ]
    business_logic_score: Annotated[int, Field(alias="Business Logic Score (1-5)")]
    business_logic_score_reasoning: Annotated[str, Field(alias="Business Logic Score Reasoning")]
    safety_compliance_score_pass: Annotated[
        bool, Field(alias="Safety Compliance Score (Pass/Fail)")
    ]
    safety_compliance_score_reasoning: Annotated[
        str, Field(alias="Safety Compliance Score Reasoning")
    ]
    efficiency_score: Annotated[int, Field(alias="Efficiency Score (1-5)")]
    efficiency_score_reasoning: Annotated[str, Field(alias="Efficiency Score Reasoning")]
    static_checks_score_pass: Annotated[bool, Field(alias="Static Checks Score (Pass/Fail)")]
    static_checks_reasoning: Annotated[str, Field(alias="Static Checks Reasoning")]

    @override
    def calculate_final_score(self) -> int | float:
        """Calculates a weighted average score for the test case.

        Converts boolean 'Pass/Fail' metrics into numerical values (5 for Pass, 1 for Fail).

        Returns:
            float: The final weighted score for the test case.

        """
        return utils.average(
            self.business_logic_score,
            self.efficiency_score,
            utils.bool_score_to_int_score(passed=self.syntax_and_executive_validity_score_pass),
            utils.bool_score_to_int_score(passed=self.safety_compliance_score_pass),
            utils.bool_score_to_int_score(passed=self.static_checks_score_pass),
        )

    @override
    @classmethod
    def from_columns(
        cls,
        test_case: TestCase[SqlQueryInput],
        test_output: SqlQueryOutput,
        llm_checks_columns: LlmChecksColumn,
        static_checks_columns: StaticChecksColumn,
    ) -> Self:
        """Factory method to create a report row from evaluation results.

        Returns:
            A new instance of the class
        """
        row: Self = cls.model_validate(
            {
                "final_score": -1,
                "identifier": test_case.id,
                "name": test_case.name,
                "description": test_case.description,
                "input": test_case.input,
                "output": test_output,
                "syntax_and_executive_validity_score_pass": (
                    llm_checks_columns.syntax_and_executive_validity_score_pass
                ),
                "syntax_and_executive_validity_score_reasoning": (
                    llm_checks_columns.syntax_and_executive_validity_score_reasoning
                ),
                "business_logic_score": llm_checks_columns.business_logic_score,
                "business_logic_score_reasoning": llm_checks_columns.business_logic_score_reasoning,
                "efficiency_score": llm_checks_columns.efficiency_score,
                "efficiency_score_reasoning": llm_checks_columns.efficiency_score_reasoning,
                "safety_compliance_score_pass": llm_checks_columns.safety_compliance_score_pass,
                "safety_compliance_score_reasoning": (
                    llm_checks_columns.safety_compliance_score_reasoning
                ),
                "static_checks_score_pass": static_checks_columns.static_checks_score_pass,
                "static_checks_reasoning": static_checks_columns.static_checks_reasoning,
            },
            by_name=True,
        )
        row.final_score = row.calculate_final_score()
        return row

    @property
    @override
    def score_range(self) -> ScoreRange:
        return ScoreRange(min=1, max=5)
